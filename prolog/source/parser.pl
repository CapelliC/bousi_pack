%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bousi-Prolog parser

:- module(parser, [
		parse_program/7,        % +ProgramFile, +OntologyFile, -Directives,
                                %  -Rules, -Equations, -LingTerms,
		                        %  -Messages
		parse_query/5           % +ProgramPrefix, +String, -Query,
		                        %  -LingTerms, -Messages
   ]).

:- use_module(directives).
:- use_module(utilities).

:- use_module(library(lists)).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- set_prolog_flag(double_quotes, codes).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parser predicates for Bousi-Prolog files
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% parse_program(+ProgramFile, +OntologyFile, -Directives, -Rules, -Equations, -LingTerms, -Messages)
%
%     Reads a Bousi-Prolog program together with a Bousi-Prolog
%     ontology, performs a lexical, syntactic and semantic analysis,
%     and returns the following:
%
%      * All directives, rules (including facts) and equations found in
%        source code files.
%      * A list with the linguistic terms built with the '#' operator
%        that were found in source code files.
%      * All errors and warnings generated by the parser.
%
%     OntologyFile can be '' (an empty string) if no ontology is
%     needed. The five lists returned by this predicate follow an
%     intermediate format intended to be read by 'translator' module
%     in order to build a TPL file.
%
%     @see translate_program/3
%

parse_program(ProgramFile, OntologyFile, Directives, Rules, Equations,
              LingTerms, Messages) :-
              
	% Sets the prefix for the user-defined predicates
	utilities:simplify_filename(ProgramFile, SimplifiedFilename),
	program_prefix(OldProgramPrefix),
	retract(program_prefix(OldProgramPrefix)),
	assert(program_prefix(SimplifiedFilename)),
	% Reads and parses program file
	reset_parser,
	parse_file(ProgramFile, DirectivesF, RulesF, EquationsF),
	% Checks if an ontology needs to be loaded
	(OntologyFile == '' ->
		DirectivesO = [], RulesO = [], EquationsO = [],
		(RulesF == [], not((DirectivesF == [], EquationsF == [])) ->
			add_message_in_file(ProgramFile,
				'Program have no rules and seems to be an ontology. \c
				Use \'ld -o\' if you want to load an ontology into a program.',
				warning)
		;
			true
		)
	;
		% Reads and parses ontology file
		parse_file(OntologyFile, DirectivesO, RulesO, EquationsO),
		(RulesO == [] ->
			true
		;
			add_message_in_file(OntologyFile,
				'Ontologies can only contain equations and directives.',
			    error)
		)
	),
	% Sorts all errors and warnings by file name, line and column
	messages(UnsortedMessages),
	sort(UnsortedMessages, Messages),
	% Joins directives, equations and rules of both files
	append(DirectivesF, DirectivesO, Directives),
	append(RulesF, RulesO, Rules),
	append(EquationsF, EquationsO, Equations),
	% Gets the linguistic terms found in source code files and removes duplicates
	linguistic_terms(LingTermsWithDuplicates),
	list_to_set(LingTermsWithDuplicates, LingTerms).


%% parse_file(+File, -Directives, -Rules, -Equations)
%
%     Reads a Bousi-Prolog source file, performs a lexical, syntactic
%     and semantic analysis, and returns three lists with all the
%     directives, rules (including facts) and equations found. These
%     lists follow an intermediate format intended to be read by
%     'translator' module in order to build a TPL file.
%

parse_file(File, Directives, Rules, Equations) :-
	% Saves source code filename, which will be used to show errors
	bpl_filename(OldFile),
	retract(bpl_filename(OldFile)),
	assert(bpl_filename(File)),
	% Opens file and reads its contents
	read_file_to_codes(File, Codes, []),
	atom_codes(Atom, Codes),
	% Parses source code
	foreign:ext_tokenize(Atom, Tokens),
	phrase(bousi_prolog_program(Directives, Rules, Equations), Tokens),
	!,
	% Restores original filename
	retract(bpl_filename(File)),
	assert(bpl_filename(OldFile)).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parser predicates for Bousi-Prolog queries
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% parse_query(+ProgramPrefix, +String, -Query, -LingTerms)
%
%     Reads the query contained in String atom, performs a lexical,
%     syntactic and semantic analysis, and (if no errors are found)
%     returns the following:
%
%      * A term that can be used to execute the query by means of the
%        'evaluator' module.
%      * A list with the linguistic terms built with the '#' operator
%        that were found in the query.
%
%     Both the Query and the LingTerms list returned by this predicate
%     follow an intermediate format intended to be read by 'translator'
%     module.
%
%     @see translate_query/4
%

parse_query(ProgramPrefix, String, Query, LingTerms, Messages) :-
	% Sets the prefix for user-defined predicates
	program_prefix(OldProgramPrefix),
	retract(program_prefix(OldProgramPrefix)),
	assert(program_prefix(ProgramPrefix)),
	% Parses query
	reset_parser,
	foreign:ext_tokenize(String, Tokens),
	phrase(query(Query), Tokens),
	!,
	% Sorts all errors and warnings by file name, line and column
	messages(UnsortedMessages),
	sort(UnsortedMessages, Messages),
	% Gets the linguistic terms found in the query and removes duplicates
	linguistic_terms(LingTermsWithDuplicates),
	list_to_set(LingTermsWithDuplicates, LingTerms).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DCG (Definite Clause Grammar) rules for parsing Bousi-Prolog programs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% bousi_prolog_program(-Directives, -Rules, -Equations)
%
%     DCG rule which parses a full Bousi-Prolog program and saves all
%     directives, rules (including facts) and fuzzy relation equations
%     in Directives, Rules and Equations lists, respectively. This rule
%     manages syntax errors and tries to continue parsing if one of
%     them is found, so it won't fail even if the Bousi-Prolog program
%     has errors.
%

bousi_prolog_program([], [], []) -->
	% Normal end-of-file
	[eof(_, _)].

bousi_prolog_program(Directives, Rules, Equations) -->
	% Bousi-Prolog equation
	bpl_equation(Equations1, _),
	{
		!
	},
	bousi_prolog_program(Directives, Rules, Equations2),
	{
		append(Equations1, Equations2, Equations)
	}.

bousi_prolog_program(Directives, Rules, Equations) -->
	% Bousi-Prolog specific directive
	% The directive wn_gen_prox_equations generates new proximity equations as well
	bpl_directive(Directives1, ReplacedDirectives1, Equations1, _),
	{
		!
	},
	bousi_prolog_program(Directives2, Rules, Equations2),
	{
		append(Directives1, Directives2, Directives),
		append(Equations1, Equations2, Equations3),
		% With the rules already read, generate proximity equations for the directive wn_gen_prox_equations in auto mode
		add_auto_gen_prox_equations(ReplacedDirectives1, Rules, Equations3, Equations)
	}.

bousi_prolog_program(Directives, Rules, Equations) -->
	% Special include/1 directive
	include_directive(Directives1, Rules1, Equations1, _),
	{
		!
	},
	bousi_prolog_program(Directives2, Rules2, Equations2),
	{
		append(Directives1, Directives2, Directives),
		append(Rules1, Rules2, Rules),
		append(Equations1, Equations2, Equations)
	}.

bousi_prolog_program(Directives, Rules, Equations) -->
	% Prolog directive
	directive(Directives1, _),
	{
		!
	},
	bousi_prolog_program(Directives2, Rules, Equations),
	{
		append(Directives1, Directives2, Directives)
	}.

bousi_prolog_program(Directives, Rules, Equations) -->
	% Rule or fact
	rule(Rules1, [Line, _]),
	{
		!,
		Rules1 = [[RuleContent, _HeadBlockConstraints, _BodyBlockConstraints, _RuleDegreeVars]],
		check_singleton(RuleContent, Line),
		check_free_variables(RuleContent, Line, false)
	},
	bousi_prolog_program(Directives, Rules2, Equations),
	{
		append(Rules1, Rules2, Rules)
	}.

bousi_prolog_program(Directives, Rules, Equations) -->
	% If all of the previous rules fail, there must be a syntax error
	% in source code; this rule will try to find it and go on parsing
	bousi_prolog_program_error(Directives, Rules, Equations).

	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% add_auto_gen_prox_equations(+Directives, +Rules, -InEquations, -OutEquations)
%%%
%%% If Directives is [:- directive(wn_gen_prox_equations, [Measure, Auto])], then 
%%% return in OutEquations all the equations derived from constants in Rules
%%% Otherwise, return InEquations

add_auto_gen_prox_equations([:- directive(Directive, [Measure, Auto])], Rules, InEquations, OutEquations) :-
  Directive==wn_gen_prox_equations,
  \+ is_list(Auto),
  !,
  wn_gen_prox_equations:wn_auto_gen_prox_equations([:- directive(Directive, [Measure, Auto])], Rules, InEquations, OutEquations).
  
add_auto_gen_prox_equations(_Directives, _Rules, Equations, Equations).


%% bpl_directive(-Directives, -ReplacedDirectives, -Equations, -LineColumn)
%
%     DCG rule which parses a Bousi-Prolog specific directive and returns
%     it inside a directive/2 directive (e.g., ':- transitivity(yes).' is
%     translated into ':- directive(transitivity, [yes]).').
%
%     A directive, such as wn_gen_prox_equations, can be replaced by the 
%     proximity equations it generates
%

bpl_directive(Directives, ReplacedDirectives, Equations, [Line, Column]) -->
	[name(':-', [Line, Column])], term(Term, [], _), [name('.', _)],
	{
		parse_expression(Term, ResultTerm),
		ResultTerm =.. [Name|Arguments],
		catch((
			% Checks if specified directive is a valid BPL directive
			directives:is_directive_valid(Name, Arguments),
			% Executes the directive
			directives:directive(Name, Arguments, Equations),
			(directives:replaced_directive(Name) ->
			   Directives = [],
			   ReplacedDirectives = [:- directive(Name, Arguments)]
			  ;
			   Directives = [:- directive(Name, Arguments)],
			   ReplacedDirectives = [])
		% (catcher)
		), directive_error(ErrorMessage), (
			% Directive isn't valid
			add_message(ErrorMessage, Line, Column, error),
			Directives = []
		))
	}.


%% bpl_equation(-Equation, -LineColumn)
%
%     DCG rule which parses a Bousi-Prolog proximity, similarity or fuzzy
%     relation equation "a <op> b = n." (where <op> can be any of the
%     Bousi-Prolog relation operators) and returns it in Equation list as
%     a term with this syntax: "<name>(a, b, n)" (where <name> is the
%     internal name of <op>). <op> and <name> are related using
%     the relation_name/2 predicate of the 'utilities' module.
%

bpl_equation(Equation, [Line, Column]) -->
	symbol(Sym1, [Line, Column]), [relation(RelOp, _)], symbol(Sym2, _),
	[name('=', _)], number_(Value, [LineValue, ColumnValue]), [name('.', _)],
	{
		((Value >= 0.0, Value =< 1.0)
		 ->
			utilities:relation_name(RelOp, RelName),
			(RelName == sim,
			 flags:get_bpl_flag(lambda_cut(LambdaCut)),
			 LambdaCut > Value
			 ->
  			add_message('Equation not loaded: value is below the lambda cut.',
  				LineValue, ColumnValue, warning),
  			Equation = []
  		;
			 EqAux =.. [RelName, Sym1, Sym2, Value], Equation = [EqAux]
			 )
		 ;
			add_message('Equation value is not a number in range [0.0, 1.0].',
				LineValue, ColumnValue, error),
			Equation = []
		)
	}.


%% include_directive(-Directives, -Equations, -Rules, -LineColumn)
%
%     DCG rule which parses the special include/1 directive, reads the
%     included Bousi-Prolog source code file and return all directives,
%     rules and equations found in it.
%

include_directive(Directives, Rules, Equations, [Line, Column]) -->
	[name(':-', [Line, Column])], atom_('include', _),
	[left_parenthesis(_, _)], atom_(QuotedFile, _), [right_parenthesis(_, _)],
	[name('.', _)],
	{
		% Gets the real path of the included file
		utilities:remove_quotes(QuotedFile, File),
		(is_absolute_file_name(File) ->
			RealFile = File
		;
			% Joins the path of the BPL file that is being parsed and the
			% included filename to get its real path; this is needed if the
			% BPL file isn't in the current working directory, for example
			% if '/home/user/pl/a.bpl' contains ':- include('b.bpl').' and
			% the file is loaded from '/home/user' using 'ld pl/a.bpl', the
			% real path of the included file isn't 'b.bpl', but 'pl/b.bpl'
			bpl_filename(CurrentFile),
			file_directory_name(CurrentFile, CurrentDirectory),
			concat_atom([CurrentDirectory, '/', File], RealFile)
		),
		% Checks whether the included file exists
		(exists_file(RealFile) ->
			% Parses recursively the included file
			parse_file(RealFile, Directives, Rules, Equations)
		;
			% Included file doesn't exist or path is invalid
			swritef(Message, 'Included file does not exist: \'%w\'.', [RealFile]),
			add_message(Message, Line, Column, error),
			Directives = [], Rules = [], Equations = []
		)
	}.


%% directive(-Directive, -LineColumn)
%
%     DCG rule which parses a Prolog directive and returns it in
%     Directive list. If the parsed directive declares new operators,
%     this predicate will add them to custom operator list to allow
%     them to be used in following statements.
%

directive([Directive], [Line, Column]) -->
	[name(':-', [Line, Column])], term(Term, [], _), [name('.', _)],
	{
		parse_expression(Term, ResultTerm),
		% Checks if this directive needs a special treatment
		(ResultTerm = op(OpPrio, OpType, OpName) ->
			(atom(OpName) ->
				% Directive declares a single operator
				declare_custom_operator(OpPrio, OpType, [OpName])
			;
				% Directive declares a list of operators
				declare_custom_operator(OpPrio, OpType, OpName)
			),
			Directive = (:- ResultTerm)
		;
		(ResultTerm = dynamic(Pred/Arity) ->
			% Directive declares a dynamic predicate, so its name and
			% arity must be changed from 'pred/2' to 'prefix_pred/3'
			program_prefix(Prefix),
			concat_atom([Prefix, '_', Pred], NewPred),
      translator:expanded_rule_arity(Arity, NewArity),
			Directive = (:- dynamic(NewPred/NewArity))
		;
		(ResultTerm = discontiguous(Pred/Arity) ->
			% Directive declares a dynamic predicate, so its name and
			% arity must be changed from 'pred/2' to 'prefix_pred/3'
			program_prefix(Prefix),
			concat_atom([Prefix, '_', Pred], NewPred),
      translator:expanded_rule_arity(Arity, NewArity),
			Directive = (:- discontiguous(NewPred/NewArity))
		;
			% No special treatment needed
			Directive = (:- ResultTerm)
		)))
	}.


%% rule(-Rule, -LineColumn)
%
%     DCG rule which parses a Prolog/Bousi-Prolog clause and converts
%     it into a list with an intermediate format that can be later
%     used by the 'translator' module. The returned list will have the
%     following items:
%
%      * A copy of the original clause in which the rule's head and
%        each call to a user-defined predicate has been modified in
%        order to add a degree variable and the prefix of the program
%        being compiled.
%      * The list of degree variables added to the rule's body.
%
%     For example, if the program being loaded is called "prog.bpl",
%     given the rule "a(X) :- b(X), c, true", the parser will translate
%     this rule into a list with these two items:
%
%      * a) prog_a(X, DG) :- prog_b(X, D1), prog_c(D2), true.
%      * b) [D1, D2]
%

rule([Rule], [Line, Column]) -->
	basic_prolog_term(HeadWithoutDegreeVar, [Line, Column]),
	(
		% Clause is a rule
		[name(':-', _)],
		term(Term, [not_allowed_ops([':-'])], _),
		[name('.', _)],
		{
			% Checks if the rule's head references an existing predicate
			(utilities:builtin(HeadWithoutDegreeVar) ->
				functor(HeadWithoutDegreeVar, Functor, Arity),
				swritef(Message, 'No permission to redefine built-in predicate \'%w/%w\'.', [Functor, Arity]),
				add_message(Message, Line, Column, error)
			;
				true
			),
			% Translates the list of terms and operators returned by term/2
			% into a real Prolog term
			parse_expression(Term, BodyWithoutDegreeVars),
			% Adds the degree variables to rule's body
			add_degree_variables(BodyWithoutDegreeVars, BodyWithDegreeVars, RuleDegreeVars),
			% Adds the block constraints variables to rule's body
			add_block_constraints_variables(BodyWithDegreeVars, Body, BodyConstraintBlockVars)
		}
	;
		% Clause is a fact
		[name('.', _)],
		{
			% Checks if the rule's head references an existing predicate
			(utilities:builtin(HeadWithoutDegreeVar) ->
				functor(HeadWithoutDegreeVar, Functor, Arity),
				swritef(Message, 'No permission to redefine built-in predicate \'%w/%w\'.', [Functor, Arity]),
				add_message(Message, Line, Column, error)
			;
				true
			),
			Body = true,
			RuleDegreeVars = [],
			BodyConstraintBlockVars = [C, C]
		}
	),
	{
		% Adds a degree variable to rule's head
		add_degree_variables(HeadWithoutDegreeVar, HeadWithDegreeVar, _HeadDegreeVars),
		% Adds the block constraints variables to rule's body
		add_block_constraints_variables(HeadWithDegreeVar, Head, HeadConstraintBlockVars),
		% Builds a list with the parsed rule and the list of degree
		% variables created while scanning its body
		Rule = [(Head :- Body), HeadConstraintBlockVars, BodyConstraintBlockVars, RuleDegreeVars]
	}.


%% term(-Term, +Options, -LineColumn)
%
%     DCG rule which parses a Prolog/Bousi-Prolog atomic or compound
%     term and returns each of its components (operands and operators)
%     in a list. Operators are stored in terms with this syntax:
%     'exp_operator(<operator>, <prefix/infix>, [<line>, <column>])'.
%
%     Options is a list that can contain the following items:
%
%      * not_allowed_ops(+Operators): Operators is a list of operators
%        that can't be used as the main operator in this term.
%      * no_comparisons: indicates that the parsed term can't be a
%        Bousi-Prolog weak unification or term comparison.
%

%% remaining_term(-RemainingTerm, +Options)
%
%     Helper DCG rule used by term/3 to reduce backtracking and increase
%     analysis speed.
%
%     @see term/3
%

term(Term, Options, [Line, Column]) -->
	% Term with a prefix operator (operator can't be '\+' nor 'not'
	% because negations are handled in basic_prolog_term/2 rule)
	operator(Operator, [Line, Column]),
	{
		% Checks that operator is allowed
		Operator \== \+, Operator \== not,
		(member(not_allowed_ops(NotAllowedOps), Options) ->
			not(member(Operator, NotAllowedOps))
		;
			true
		),
		% Verifies that operator is defined and it's a prefix one
		operator_type(_, OpType, Operator),
		member(OpType, [fx, fy])
	},
	term(SingleTerm, Options, _),
	{
		Term = [exp_operator(Operator, prefix, [Line, Column])|SingleTerm]
	}.

term(Term, Options, [Line, Column]) -->
	% Term with an infix operator, or without operator
	basic_term(FirstTerm, Options, [Line, Column]),
	remaining_term(RemainingTerm, Options),
	{
		append([FirstTerm], RemainingTerm, Term)
	}.

remaining_term(RemainingTerm, Options) -->
	% Infix operator
	operator(Operator, [LineOp, ColumnOp]),
	{
		(member(not_allowed_ops(NotAllowedOps), Options) -> 
			not(member(Operator, NotAllowedOps))
		;
			true
		),
		operator_type(_, OpType, Operator),
		member(OpType, [xfx, xfy, yfx])
	},
	term(Term, Options, _),
	{
		RemainingTerm = [exp_operator(Operator, infix, [LineOp, ColumnOp])|Term]
	}.

remaining_term([], _Options) -->
	% No operator
	[].


%% basic_term(-Term, +Options, -LineColumn)
%
%     DCG rule which parses and returns a Prolog/Bousi-Prolog term
%     without operators. For a list of valid Options, see term/3.
%
%     @see term/3
%

basic_term(RelName, _Options, [Line, Column]) -->
	% Single BPL operator
	[relation(RelOperator, [Line, Column])],
	{
		utilities:relation_name(RelOperator, RelName)
	}.

basic_term(Term, _Options, [Line, Column]) -->
	% Prolog term
	basic_prolog_term(Term, [Line, Column]).

basic_term(BPLTerm, Options, [Line, Column]) -->
	% Bousi-Prolog weak unification or term comparison
	{
		not(member(no_comparisons, Options))
	},
	bpl_comparison(BPLTerm, [Line, Column]).


%% bpl_comparison(-BPLTerm, -LineColumn)
%
%     DCG rule which parses and returns a Bousi-Prolog weak unification
%     (e.g. "a(X) ~ b(X) < 0.5") or term comparison (e.g. "a ~> b =:= 1").
%

bpl_comparison(BPLTerm, [Line, Column]) -->
	% Weak unification operator (~)
	basic_term(BasicTerm1, [no_comparisons], [Line, Column]),
	[relation('~', _)],
	basic_term(BasicTerm2, [no_comparisons], _),
	[name(Operator, _)], number_or_variable(Value, _),
	{
		member(Operator, [=, =:=, =\=, =<, >=, >, <]),
		% A term like "a(X) ~ b(X) >= 0.5" is translated into:
		% "unify_a1(a(X), b(X), >=, 0.5)"
		unify_predicate_name(UnifyPredicateName) ,
		BPLTerm =.. [UnifyPredicateName, BasicTerm1, BasicTerm2, Operator, Value]
	}.

bpl_comparison(BPLTerm, [Line, Column]) -->
	% Syntactic sugar: "a ~ b" is equivalent to "a ~ b > 0"
	basic_term(BasicTerm1, [no_comparisons], [Line, Column]),
	[relation('~', _)],
	basic_term(BasicTerm2, [no_comparisons], _),
	{
		unify_predicate_name(UnifyPredicateName),
		BPLTerm =.. [UnifyPredicateName, BasicTerm1, BasicTerm2, >, 0]
	}.

bpl_comparison(BPLTerm, [Line, Column]) -->
	% Extended BPL operators (~>, <~, ~1~, ~2~, ~3~)
	basic_term(BasicTerm1, [no_comparisons], [Line, Column]),
	[relation(RelOperator, _)],
	basic_term(BasicTerm2, [no_comparisons], _),
	[name(Operator, _)], number_or_variable(Value, _),
	{
		RelOperator \== '~',
		utilities:relation_name(RelOperator, RelName),
		utilities:relation_evaluator(RelName, RelEvaluator),
		member(Operator, [=, =:=, =\=, =<, >=, >, <]),
		% A term like "a(X) ~2~ b(X) =:= 1.0" is translated into:
		% "e_frel2(a(X), b(X), _Degree, =:=, 1.0)"
		BPLTerm =.. [RelEvaluator, BasicTerm1, BasicTerm2, Operator, Value]
	}.

bpl_comparison(BPLTerm, [Line, Column]) -->
	% Syntactic sugar: "a · b" is equivalent to "a · b > 0"
	basic_term(BasicTerm1, [no_comparisons], [Line, Column]),
	[relation(RelOperator, _)],
	basic_term(BasicTerm2, [no_comparisons], _),
	{
		RelOperator \== '~',
		utilities:relation_name(RelOperator, RelName),
		utilities:relation_evaluator(RelName, RelEvaluator),
		BPLTerm =.. [RelEvaluator, BasicTerm1, BasicTerm2, >, 0]
	}.


unify_predicate_name(UnifyPredicateName) :-
		flags:get_bpl_flag(weak_unification(Algorithm)),
		atom_concat('unify_', Algorithm, UnifyPredicateName).
		
		
%% basic_prolog_term(-Term, -LineColumn)
%
%     DCG rule which parses and returns a Prolog atomic term or a
%     Prolog compound term with functional notation. This rule will
%     also consider Bousi-Prolog linguistic terms built with the '#'
%     operator as valid atoms.
%

basic_prolog_term(Number, [Line, Column]) -->
	% Integer number
	[integer(Number, [Line, Column])].

basic_prolog_term(Number, [Line, Column]) -->
	% Floating point number
	[float(Number, [Line, Column])].

basic_prolog_term(Variable, [Line, Column]) -->
	% Variable
	[variable(Variable, [Line, Column])].

basic_prolog_term(HigherOrderTerm, [Line, Column]) -->
	% Higher-order predicate (includes negated terms)
	higher_order_prolog_term(HigherOrderTerm, [Line, Column]).

basic_prolog_term(Compound, [Line, Column]) -->
	% Compound term (functional notation)
	atom_or_linguistic_term(Atom, [Line, Column]),
	[left_parenthesis(_, _)], argument_list(Args, _), [right_parenthesis(_, _)],
	{
		Compound =.. [Atom|Args]
	}.

basic_prolog_term(InnerTerm, [Line, Column]) -->
	% Term in parenthesis
	[left_parenthesis(_, [Line, Column])], term(Term, [], _), [right_parenthesis(_, _)],
	{
		parse_expression(Term, InnerTerm)
	}.

basic_prolog_term(List, [Line, Column]) -->
	% Non-empty list
	[left_bracket(_, [Line, Column])], items(List, _), [right_bracket(_, _)].

basic_prolog_term(CharCodeList, [Line, Column]) -->
	% String as a character code list
	[character_code_list(CharCodeList, [Line, Column])].

basic_prolog_term(Atom, [Line, Column]) -->
	% Atom (including empty list)
	atom_or_linguistic_term(Atom, [Line, Column]).


%% bpl_linguistic_term(-BPLTerm, -LineColumn)
%
%     DCG rule which parses a Bousi-Prolog linguistic term built with
%     the '#' operator, creates the definition of the associated fuzzy
%     subset (using the notation required by ext_translate_fuzzysets/5),
%     and returns the simplified name of the subset. A reference to the
%     subset is also saved in the linguistic_terms/1 dynamic predicate.
%

bpl_linguistic_term(BPLTerm, [Line, Column]) -->
	% 1st type: crisp domain ranges
	% domain#minimum#maximum (e.g., height#20#100)
	[name(Domain, [Line, Column])], [builder(_, _)],
	integer_number(Minimum, _), [builder(_, _)],
	integer_number(Maximum, _),
	{
		% Builds the name and the definition of the fuzzy subset
		% 'height#20#100' is translated into 'height_20_100(between(20, 100))'
		concat_atom([Domain, '_', Minimum, '_', Maximum], InitialBPLTerm),
		utilities:simplify_atom(InitialBPLTerm, BPLTerm),
		NewSubset =.. [BPLTerm, between(Minimum, Maximum)],
		% Adds the new subset to the list of linguistic terms
		linguistic_terms(OldLingTerms),
		retract(linguistic_terms(OldLingTerms)),
		append(OldLingTerms, [[domain, Domain, NewSubset]], NewLingTerms),
		assert(linguistic_terms(NewLingTerms))
	}.

bpl_linguistic_term(BPLTerm, [Line, Column]) -->
	% 2nd type: fuzzy domain ranges
	% modifier#domain#minimum#maximum (e.g., about#speed#100#120)
	% Valid modifiers: [about]
	[name(Modifier, [Line, Column])], [builder(_, _)],
	[name(Domain, _)], [builder(_, _)],
	integer_number(Minimum, _), [builder(_, _)],
	integer_number(Maximum, _),
	{
		% Builds the name and the definition of the fuzzy subset
		% 'about#speed#100#120' is translated into
		% 'about_speed_100_120(about(100, 120))'
		member(Modifier, [about]),
		concat_atom([Modifier, '_', Domain, '_', Minimum, '_', Maximum], InitialBPLTerm),
		utilities:simplify_atom(InitialBPLTerm, BPLTerm),
		NewSubsetDef =.. [Modifier, Minimum, Maximum],
		NewSubset =.. [BPLTerm, NewSubsetDef],
		% Adds the new subset to the list of linguistic terms
		linguistic_terms(OldLingTerms),
		retract(linguistic_terms(OldLingTerms)),
		append(OldLingTerms, [[domain, Domain, NewSubset]], NewLingTerms),
		assert(linguistic_terms(NewLingTerms))
	}.

bpl_linguistic_term(BPLTerm, [Line, Column]) -->
	% 3rd type: domain points
	% domain#value (e.g., temperature#38)
	[name(Domain, [Line, Column])], [builder(_, _)],
	integer_number(Number, _),
	{
		% Builds the name and the definition of the fuzzy subset
		% 'temperature#38' is translated into 'temperature_38(point(38))'
		concat_atom([Domain, '_', Number], InitialBPLTerm),
		utilities:simplify_atom(InitialBPLTerm, BPLTerm),
		NewSubset =.. [BPLTerm, point(Number)],
		% Adds the new subset to the list of linguistic terms
		linguistic_terms(OldLingTerms),
		retract(linguistic_terms(OldLingTerms)),
		append(OldLingTerms, [[domain, Domain, NewSubset]], NewLingTerms),
		assert(linguistic_terms(NewLingTerms))
	}.

bpl_linguistic_term(BPLTerm, [Line, Column]) -->
	% 4th type: fuzzy domain points
	% modifier#domain#value (e.g., about#age#50)
	% Valid modifiers: [about]
	[name(Modifier, [Line, Column])], [builder(_, _)],
	[name(Domain, _)], [builder(_, _)],
	integer_number(Value, _),
	{
		% Builds the name and the definition of the fuzzy subset
		% 'about#age#50' is translated into 'about_age_50(about(50))'
		member(Modifier, [about]),
		concat_atom([Modifier, '_', Domain, '_', Value], InitialBPLTerm),
		utilities:simplify_atom(InitialBPLTerm, BPLTerm),
		NewSubsetDef =.. [Modifier, Value],
		NewSubset =.. [BPLTerm, NewSubsetDef],
		% Adds the new subset to the list of linguistic terms
		linguistic_terms(OldLingTerms),
		retract(linguistic_terms(OldLingTerms)),
		append(OldLingTerms, [[domain, Domain, NewSubset]], NewLingTerms),
		assert(linguistic_terms(NewLingTerms))
	}.


bpl_linguistic_term(BPLTerm, [Line, Column]) -->
	% 5th type: compound linguistic terms
	% modifier#subset (e.g., extremely#small)
	% Valid modifiers: [very, somewhat, more_or_less, extremely]
	[name(Modifier, [Line, Column])], [builder(_, _)],
	[name(Subset, _)],
	{
		% Builds the name and the definition of the fuzzy subset
		% 'extremely#small' is translated into 'extremely_small(extremely(small))'
		member(Modifier, [very, somewhat, more_or_less, extremely]),
		concat_atom([Modifier, '_', Subset], InitialBPLTerm),
		utilities:simplify_atom(InitialBPLTerm, BPLTerm),
		NewSubsetAux =.. [Modifier, Subset],
		NewSubset =.. [BPLTerm, NewSubsetAux],
		% Adds the new subset to the list of linguistic terms
		linguistic_terms(OldLingTerms),
		retract(linguistic_terms(OldLingTerms)),
		append(OldLingTerms, [[subset, Subset, NewSubset]], NewLingTerms),
		assert(linguistic_terms(NewLingTerms))
	}.


%% higher_order_prolog_term(-Compound, -LineColumn)
%
%     DCG rule which parses a Prolog higher-order predicate. These
%     predicates requires a special treatment because Bousi-Prolog
%     adds a prefix to the names of the predicates of the program, so
%     some changes must be done to the arguments that define a goal.
%
%     Currently, these are the supported higher-order predicates:
%
%      * assert(:Goal)  [only facts are allowed]
%      * retract(:Goal) [only facts are allowed]
%      * not(:Goal)
%      * \+(:Goal)
%      * call(:Goal)
%      * once(:Goal)
%      * ignore(:Goal)
%      * time(:Goal)
%      * apply(:Goal, +List)
%      * maplist(:Goal, +List)
%      * forall(:Condition, :Action)
%      * findall(+Template, :Goal, -Bag)
%      * bagof(+Template, :Goal, -Bag)
%      * setof(+Template, :Goal, -Bag)
%      * catch(:Goal, +Catcher, :Recover)
%
%     Goals can be any kind of term, including compound terms built
%     with control predicates such as ,/2, ;/2 or ->/2. All the higher-
%     order predicates except not/1 and \+/1 are crisp and can either
%     fail or succeed with approximation degree 1.
%

higher_order_prolog_term(Compound, [Line, Column]) -->
	% Negated term
	atom_(Atom, [Line, Column]),
	{
		(Atom == not ; Atom == \+)
	},
	[left_parenthesis(_, _)],
	term(Term, [not_allowed_ops([','])], _),
	[right_parenthesis(_, _)],
	{
		parse_expression(Term, ResultTermWithoutCtrsAndDegreeVars),
%		add_degree_variables(ResultTermWithoutDegreeVars, ResultTerm, GoalDegreeVars),
		add_degree_variables(ResultTermWithoutCtrsAndDegreeVars, ResultTermWithoutCtrsVars, GoalDegreeVars),
    add_block_constraints_variables(ResultTermWithoutCtrsVars, ResultTerm, BlockConstraintsVars),
		check_free_variables(ResultTerm, Line, true),
%		var(Degree),
    (flags:get_bpl_flag(weak_unification(a1)) ->
		 Compound = eval_negation(Atom, ResultTerm, GoalDegreeVars, _Degree)
		;
		 Compound = eval_negation(Atom, ResultTerm, BlockConstraintsVars, GoalDegreeVars, _Degree)
		)
	}.

higher_order_prolog_term(Compound, [Line, Column]) -->
	% Higher-order predicates with signature "name(:Goal)" [only facts]:
	% assert/1, retract/1
	atom_(Atom, [Line, Column]),
	{
		higher_order_predicate(Atom, [atom])
	},
	[left_parenthesis(_, _)],
	basic_prolog_term(BasicTermWithoutCtrsAndDegreeVars, _),
	[right_parenthesis(_, _)],
	{
		add_degree_variables(BasicTermWithoutCtrsAndDegreeVars, BasicTermWithoutCtrsVars, _DegreeVars), % WARNING: DegreeVars are ignored
    add_block_constraints_variables(BasicTermWithoutCtrsVars, BasicTerm, _BlockConstraintsVars), % WARNING: Block constraint variables are ignored
		Compound =.. [Atom, BasicTerm]
	}.

higher_order_prolog_term(Compound, [Line, Column]) -->
	% Higher-order predicates with signature "name(:Goal)":
	% call/1, once/1, ignore/1, time/1
	atom_(Atom, [Line, Column]),
	{
		higher_order_predicate(Atom, [goal]), Atom \== \+, Atom \== not
	},
	[left_parenthesis(_, _)],
	term(Term, [not_allowed_ops([','])], _),
	[right_parenthesis(_, _)],
	{
		% Parses the inner term
		parse_expression(Term, ResultTermWithoutCtrsAndDegreeVars),
		% Adds the degree variables to the goal
		add_degree_variables(ResultTermWithoutCtrsAndDegreeVars, ResultTermWithoutCtrsVars, _GoalDegreeVars), % WARNING: DegreeVars are ignored
    add_block_constraints_variables(ResultTermWithoutCtrsVars, ResultTerm, _BlockConstraintsVars), % WARNING: Block constraint variables are ignored
		check_free_variables(ResultTerm, Line, true),
		% Creates the final compound term
		(Atom == call ->
			Compound =.. [bpl_call, ResultTerm]
		;
			BPLCall =.. [bpl_call, ResultTerm],
			Compound =.. [Atom, BPLCall]
		)
	}.

higher_order_prolog_term(Compound, [Line, Column]) -->
	% Higher-order predicates with signature "name(:Goal, +List)":
	% apply/2, maplist/2
	atom_(Atom, [Line, Column]),
	{
		higher_order_predicate(Atom, [nongoal, nongoal])
	},
	[left_parenthesis(_, _)],
	term(Term1, [not_allowed_ops([','])], _),
	[comma(_, _)],
	term(Term2, [not_allowed_ops([','])], _),
	[right_parenthesis(_, _)],
	{
		% Parses the inner terms
		parse_expression(Term1, ResultTerm1),
		parse_expression(Term2, ResultTerm2),
		% Adds the degree variables to the goals
		check_free_variables(ResultTerm1, Line, true),
		check_free_variables(ResultTerm2, Line, true),
		% Creates the final compound term
		(Atom == apply ->
			Compound =.. [bpl_apply, ResultTerm1, ResultTerm2]
		; (Atom == maplist ->
			Compound =.. [bpl_maplist, ResultTerm1, ResultTerm2]
		;
			Compound =.. [Atom, ResultTerm1, ResultTerm2]
		))
	}.

higher_order_prolog_term(Compound, [Line, Column]) -->
	% Higher-order predicates with signature "name(:Condition, :Action)":
	% forall/2
	atom_(Atom, [Line, Column]),
	{
		higher_order_predicate(Atom, [goal, goal])
	},
	[left_parenthesis(_, _)],
	term(Term1, [not_allowed_ops([','])], _),
	[comma(_, _)],
	term(Term2, [not_allowed_ops([','])], _),
	[right_parenthesis(_, _)],
	{
		% Parses the inner terms
		parse_expression(Term1, ResultTerm1WithoutCtrsAndDegreeVars),
		parse_expression(Term2, ResultTerm2WithoutCtrsAndDegreeVars),
		% Adds the degree and block constraints variables to the goals
		add_degree_variables(ResultTerm1WithoutCtrsAndDegreeVars, ResultTerm1WithoutCtrsVars, _DegreeVars1),
    add_block_constraints_variables(ResultTerm1WithoutCtrsVars, ResultTerm1, _BlockConstraintsVars1),
		add_degree_variables(ResultTerm2WithoutCtrsAndDegreeVars, ResultTerm2WithoutCtrsVars, _DegreeVars2),
    add_block_constraints_variables(ResultTerm2WithoutCtrsVars, ResultTerm2, _BlockConstraintsVars2),
		check_free_variables(ResultTerm1, Line, true),
		check_free_variables(ResultTerm2, Line, true),
		% Creates the final compound term
		BPLCall1 =.. [bpl_call, ResultTerm1],
		BPLCall2 =.. [bpl_call, ResultTerm2],
		Compound =.. [Atom, BPLCall1, BPLCall2]
	}.

higher_order_prolog_term(Compound, [Line, Column]) -->
	% Higher-order predicates with signature "name(+Template, :Goal, -Bag)":
	% findall/3, bagof/3, setof/3
	atom_(Atom, [Line, Column]),
	{
		higher_order_predicate(Atom, [nongoal, goal, nongoal])
	},
	[left_parenthesis(_, _)],
	term(Term1, [not_allowed_ops([','])], _),
	[comma(_, _)],
	term(Term2, [not_allowed_ops([','])], _),
	[comma(_, _)],
	term(Term3, [not_allowed_ops([','])], _),
	[right_parenthesis(_, _)],
	{
		% Parses the inner terms
		parse_expression(Term1, ResultTerm1),
		parse_expression(Term2, ResultTerm2WithoutCtrsAndDegreeVars),
		parse_expression(Term3, ResultTerm3),
		% Adds the degree and block constraints variables to the goals
		add_degree_variables(ResultTerm2WithoutCtrsAndDegreeVars, ResultTerm2WithoutCtrsVars, GoalDegreeVars),
    add_block_constraints_variables(ResultTerm2WithoutCtrsVars, ResultTerm2, BlockConstraintsVars),
		check_free_variables(ResultTerm2, Line, true),
		% Creates the final compound term
		((Atom == bagof ; Atom == setof) ->
			% In order to keep the original behavior of the bagof/3 and
			% setof/3 predicates, degree variables must be bound with
			% the existencial operator, ^/2
			add_call_after_bindings(ResultTerm2, BPLCallWithoutBindings),
      append(BlockConstraintsVars, GoalDegreeVars, CtrsAndDegreeVars),
			bind_term(CtrsAndDegreeVars, BPLCallWithoutBindings, BPLCall)
		;
			% findall/3 binds automatically all free variables, so
			% it isn't neccesary to bind them manually
			BPLCall =.. [bpl_call, ResultTerm2]
		),
		Compound =.. [Atom, ResultTerm1, BPLCall, ResultTerm3]
	}.

higher_order_prolog_term(Compound, [Line, Column]) -->
	% Higher-order predicates with signature "name(:Goal, +Catcher, :Recover)":
	% catch/3
	atom_(Atom, [Line, Column]),
	{
		higher_order_predicate(Atom, [goal, nongoal, goal])
	},
	[left_parenthesis(_, _)],
	term(Term1, [not_allowed_ops([','])], _),
	[comma(_, _)],
	term(Term2, [not_allowed_ops([','])], _),
	[comma(_, _)],
	term(Term3, [not_allowed_ops([','])], _),
	[right_parenthesis(_, _)],
	{
		% Parses the inner terms
		parse_expression(Term1, ResultTerm1WithoutCtrsAndDegreeVars),
		parse_expression(Term2, ResultTerm2),
		parse_expression(Term3, ResultTerm3WithoutCtrsAndDegreeVars),
		% Adds the degree and block constraints variables to the goals
		add_degree_variables(ResultTerm1WithoutCtrsAndDegreeVars, ResultTerm1WithoutCtrsVars, _DegreeVars1),
    add_block_constraints_variables(ResultTerm1WithoutCtrsVars, ResultTerm1, _BlockConstraintsVars1),
		add_degree_variables(ResultTerm3WithoutCtrsAndDegreeVars, ResultTerm3WithoutCtrsVars, _DegreeVars3),
    add_block_constraints_variables(ResultTerm3WithoutCtrsVars, ResultTerm3, _BlockConstraintsVars3),
		check_free_variables(ResultTerm1, Line, true),
		check_free_variables(ResultTerm3, Line, true),
		% Creates the final compound term
		BPLCall1 =.. [bpl_call, ResultTerm1],
		BPLCall3 =.. [bpl_call, ResultTerm3],
		Compound =.. [Atom, BPLCall1, ResultTerm2, BPLCall3]
	}.


%% argument_list(-ArgList, -LineColumn)
%
%     DCG rule which parses a non-empty argument list of a compound
%     term and returns it as a real Prolog list.
%

argument_list(ArgList, [Line, Column]) -->
	% First argument
	expression(FirstArg, [Line, Column]),
	(
		% Remaining arguments
		[comma(_, _)], argument_list(RemainingArgs, _)
	;
		% No more arguments
		{
			RemainingArgs = []
		}
	),
	{
		parse_expression(FirstArg, ResultFirstArg),
		ArgList = [ResultFirstArg|RemainingArgs]
	}.


%% items(-List, -LineColumn)
%
%     DCG rule which parses and returns a non-empty Prolog list.
%

items(List, [Line, Column]) -->
	% First item
	expression(Head, [Line, Column]),
	(
		% Remaining items ([Head, ...])
		[comma(_, _)], items(MoreItems, _)
	;
		% Tail sublist ([Head|Tail])
		[list_separator(_, _)], expression(Tail, _),
		{
			parse_expression(Tail, MoreItems)
		}
	;
		% No more items ([Head])
		{
			MoreItems = []
		}
	),
	{
		parse_expression(Head, FirstItem),
		List = [FirstItem|MoreItems]
	}.


%% expression(-Exp, -LineColumn)
%
%     DCG rule which parses and returns an expression which can appear
%     inside a Prolog list or an argument list of a compound term.
%

expression([Exp], [Line, Column]) -->
	operator(Exp, [Line, Column]),
	{
		Exp \== ','
	}.

expression(Exp, [Line, Column]) -->
	term(Exp, [not_allowed_ops([','])], [Line, Column]).


%% atom_or_linguistic_term(-Atom, -LineColumn)
%
%     DCG rule which parses and returns a Prolog atom or a Bousi-Prolog
%     linguistic term built with the '#' operator (these terms are
%     internally treated as atoms).
%

atom_or_linguistic_term(Atom, [Line, Column]) -->
	atom_(Atom, [Line, Column]).

atom_or_linguistic_term(LingTerm, [Line, Column]) -->
	bpl_linguistic_term(LingTerm, [Line, Column]).



%% atom_(-Atom, -LineColumn)
%
%     DCG rule which parses and returns a Prolog atom. Note that 'atom'
%     is a reserved predicate and thus cannot be redefined; that's why
%     this rule is called 'atom_' instead.
%

atom_(Atom, [Line, Column]) -->
	[name(Atom, [Line, Column])].

atom_([], [Line, Column]) -->
	[left_bracket(_, [Line, Column])], [right_bracket(_, _)].


%% operator(-Operator, -LineColumn)
%
%     DCG rule which parses and returns a Prolog predefined operator
%     or a custom operator declared with an op/3 directive.
%

operator(Operator, [Line, Column]) -->
	[name(Operator, [Line, Column])],
	{
		operator_type(_, _, Operator)
	}.

operator(Operator, [Line, Column]) -->
	[comma(Operator, [Line, Column])].


%% symbol(-Symbol, -LineColumn)
%
%     DCG rule which parses and returns a symbol that can appear in
%     a Bousi-Prolog equation, i.e., an atom or a linguistic term
%     built with the '#' operator.
%

symbol(Symbol, [Line, Column]) -->
	[name(Symbol, [Line, Column])].

symbol(Symbol, [Line, Column]) -->
	bpl_linguistic_term(Symbol, [Line, Column]).


%% integer_number(-Number, -LineColumn)
%
%     DCG rule which parses and returns a positive or negative integer
%     number.
%

integer_number(Number, [Line, Column]) -->
	[integer(Number, [Line, Column])].

integer_number(Number, [Line, Column]) -->
	[name(Sign, [Line, Column])], [integer(UnsignedNumber, _)],
	{
		(Sign == '-' ->
			Number is -UnsignedNumber
		; (Sign == '+' ->
			Number is UnsignedNumber
		;
			fail
		))
	}.


%% float_number(-Number, -LineColumn)
%
%     DCG rule which parses and returns a positive or negative floating
%     point number.
%

float_number(Number, [Line, Column]) -->
	[float(Number, [Line, Column])].

float_number(Number, [Line, Column]) -->
	[name(Sign, [Line, Column])], [float(UnsignedNumber, _)],
	{
		(Sign == '-' ->
			Number is -UnsignedNumber
		; (Sign == '+' ->
			Number is UnsignedNumber
		;
			fail
		))
	}.


%% number_(-Number, -LineColumn)
%
%     DCG rule which parses and returns a positive or negative integer or
%     floating point number. Note that 'number' is a reserved predicate
%     and thus cannot be redefined; that's why this rule is called
%     'number_' instead.
%

number_(Number, [Line, Column]) -->
	integer_number(Number, [Line, Column]).

number_(Number, [Line, Column]) -->
	float_number(Number, [Line, Column]).


%% number_or_variable(-NumberOrVariable, -LineColumn)
%
%     DCG rule which parses and returns an integer number, a floating
%     point number, or a variable.
%

number_or_variable(Number, [Line, Column]) -->
	number_(Number, [Line, Column]).

number_or_variable(Variable, [Line, Column]) -->
	[variable(Variable, [Line, Column])].



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DCG (Definite Clause Grammar) additional rules for parsing queries
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% query(-Query)
%
%     DCG rule which parses and returns a Prolog/Bousi-Prolog query,
%     which must be a term optionally ending with a period in which the
%     main operator isn't ':-'.
%

query(Query) -->
	term(Term, [not_allowed_ops([':-'])], _),
	query_end,
	{
		parse_expression(Term, ResultTermWithoutCtrsAndDegreeVars),
		build_query(ResultTermWithoutCtrsAndDegreeVars, Query)
	}.


%% build_query(+TermWithoutCtrsAndDegreeVars, -Query)
%
%     Adds to a term the degree variable, and also,
%     for algorithms a2 and a3, input and output 
%     block constraint variables.
%

build_query(TermWithoutCtrsAndDegreeVars, Query) :-
		add_degree_variables(TermWithoutCtrsAndDegreeVars, ResultTermWithoutCtrsVars, DegreeVars),
    add_block_constraints_variables(ResultTermWithoutCtrsVars, ResultTerm, BlockConstraintsVars),
    init_ctr_store(BlockConstraintsVars),
		Query = [ResultTerm, DegreeVars].
		

%% init_ctr_store(?BlockConstraints)
%
%     Initializes the input constraint store for algorithms 'a2' and 'a3'.
%     It does nothing for others.
%

init_ctr_store([Cin|_]) :-
	flags:get_bpl_flag(weak_unification('a3')),
  !,
  empty_assoc(Cin).
  
init_ctr_store([Cin|_]) :-
	flags:get_bpl_flag(weak_unification('a2')),
  !,
  Cin=[].
  
init_ctr_store(_Cin).


%% query_end
%
%     DCG rule which parses the end of a Prolog/Bousi-Prolog query,
%     which can be a period or just the end-of-file character.
%

query_end -->
	[name('.', _)], [eof(_, _)].

query_end -->
	[eof(_, _)].



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DCG (Definite Clause Grammar) additional rules for managing errors
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% bousi_prolog_program_error(-Directives, -Rules, -Equations)
%
%     DCG rule which parses a Prolog statement with syntax errors,
%     saves error in messages/1 predicate, looks for the beginning of
%     the next statement (actually, looks for the next period '.' in
%     source code) and then goes on parsing using
%     bousi_prolog_program/3 rule.
%
%     @see bousi_prolog_program/3
%

bousi_prolog_program_error(Directives, Rules, Equations) -->
	% Syntax error in rule body
	basic_prolog_term(_Head, _), [name(':-', _)],
	term_error([not_allowed_ops([':-'])], _),
	next_statement([LineError, ColumnError]),
	{
		!,
		add_message('Syntax error in rule body.', LineError, ColumnError, error)
	},
	bousi_prolog_program(Directives, Rules, Equations).

bousi_prolog_program_error(Directives, Rules, Equations) -->
	% Syntax error in directive body
	[name(':-', _)], term_error([not_allowed_ops([':-'])], _),
	next_statement([LineError, ColumnError]),
	{
		!,
		add_message('Syntax error in directive.', LineError, ColumnError, error)
	},
	bousi_prolog_program(Directives, Rules, Equations).

bousi_prolog_program_error(Directives, Rules, Equations) -->
	% Syntax error in fact or rule head
	term_error([not_allowed_ops([':-'])], _),
	next_statement([LineError, ColumnError]),
	{
		!,
		add_message('Syntax error in fact or rule head.', LineError, ColumnError, error)
	},
	bousi_prolog_program(Directives, Rules, Equations).

bousi_prolog_program_error(Directives, Rules, Equations) -->
	% Unknown syntax error in statement
	next_statement([LineError, ColumnError]),
	{
		!,
		add_message('Syntax error in statement.', LineError, ColumnError, error)
	},
	bousi_prolog_program(Directives, Rules, Equations).

bousi_prolog_program_error([], [], []) -->
	% End-of-file (this rule is executed only when 'eof' token has been
	% taken from input by next_statement/1 in one of the previous rules)
	[].


%% term_error(+Options, -LineColumn)
%
%     DCG rule which parses a partial Prolog/Bousi-Prolog term, until a
%     syntax error is found.
%
%     Options is a list that can only contain the following item:
%
%      * not_allowed_ops(+Operators): Operators is a list of operators
%        that can't be used as the main operator in this term.
%
%     @see term/3
%

%% remaining_term_error(+Options)
%
%     Helper DCG rule used to reduce backtracking and increase
%     analysis speed.
%

term_error(Options, [Line, Column]) -->
	% Term with prefix operator (must appear before following rule)
	operator(Operator, [Line, Column]),
	{
		(member(not_allowed_ops(NotAllowedOps), Options) ->
			not(member(Operator, NotAllowedOps))
		;
			true
		),
		operator_type(_, OpType, Operator),
		member(OpType, [fx, fy])
	},
	term_error(Options, _).

term_error(_, [Line, Column]) -->
	% Compound term (functional notation)
	atom_(_, [Line, Column]), [left_parenthesis(_, _)], term_error([], _).

term_error(Options, [Line, Column]) -->
	% Term with infix operator, or without operator
	basic_term(_, [], [Line, Column]), remaining_term_error(Options).

term_error(_, [Line, Column]) -->
	% Term in parenthesis
	[left_parenthesis(_, [Line, Column])], term_error([], _).

term_error(_, [_Line, _Column]) -->
	% Can't go on parsing term, syntax error is around here
	[].

remaining_term_error(Options) -->
	% Infix operator
	operator(Operator, _),
	{
		(member(not_allowed_ops(NotAllowedOps), Options) -> 
			not(member(Operator, NotAllowedOps))
		;
			true
		),
		operator_type(_, OpType, Operator),
		member(OpType, [xfx, xfy, yfx])
	},
	term_error(Options, _).

remaining_term_error(_) -->
	% No operator
	[].


%% next_statement(-LineColumn)
%
%     DCG rule which matches all tokens in input until end-of-file is
%     reached or a period is found. The end-of-file or period token
%     is also taken from input. This rule is used by
%     bousi_prolog_program_error/3 to skip a statement with syntax
%     errors.
%

next_statement([Line, Column]) -->
	% There is a period before end-of-file
	all_tokens('.', [LineError, ColumnError]), [name('.', [LinePeriod, ColumnPeriod])],
	{
		((var(LineError), var(ColumnError)) ->
			% There aren't any tokens before period
			Line = LinePeriod, Column = ColumnPeriod
		;
			% There is at least one token before period
			Line = LineError, Column = ColumnError
		)
	}.

next_statement([Line, Column]) -->
	% There are no periods before end-of-file
	all_tokens('.', [LineError, ColumnError]), [eof(_, [LineEOF, ColumnEOF])],
	{
		((var(LineError), var(ColumnError)) ->
			% There aren't any tokens before end-of-file
			Line = LineEOF, Column = ColumnEOF
		;
			% There is at least one token before end-of-file
			Line = LineError, Column = ColumnError
		)
	}.


%% all_tokens(+EndText, -LineColumn)
%
%     DCG rule which matches all tokens in input until end-of-file is
%     reached or a token with text EndText is found. The end-of-file
%     or EndText token won't be taken from input, so this rule can
%     succeed without eating any token.
%

all_tokens(EndText, [Line, Column]) -->
	[Token],
	{
		Token =.. [Type, Text, [Line, Column]],
		Type \== eof, Text \== EndText
	},
	all_tokens(EndText, _).

all_tokens(_, [_Line, _Column]) -->
	[].



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Predicates for parsing expressions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% parse_expression(+Expression, ?SyntaxTree)
%
%     Scans a "plain" expression list returned by term/2 DCG rule and
%     returns the syntax tree which represents the real expression
%     structure. If an operator priority clash is detected, an error
%     will be generated and SyntaxTree will be unified with 'error'.
%

%% parse_expression_aux(+Expression, ?SyntaxTree)
%
%     Internal predicate which doesn't catch exceptions.
%
%     @throws parse_error(Message, [Line, Column]) An operator
%      priority clash was detected.
%
%     @see parse_expression/2
%

parse_expression(Expression, SyntaxTree) :-
	catch((
		parse_expression_aux(Expression, SyntaxTree)
	% (catcher)
	), parse_error(Message, [Line, Column]), (
		% Operator priority clash (here SyntaxTree can be unified
		% with any term, as no TPL file nor query won't be generated)
		(add_message(Message, Line, Column, error), SyntaxTree = error)
	)), !.
	
parse_expression_aux([Expression], Expression) :-
	% The expression just contains a single operand
	!.

parse_expression_aux(Expression, SyntaxTree) :-
	% Looks for the highest operator in Expression
	highest_operator(Expression, [Operator, _, _, Index]),
	% Splits the "plain" expression list into two sublists
	length(LeftExpression, Index),
	append(LeftExpression, [exp_operator(Operator, Location, _)|RightExpression], Expression),
	(Location == infix ->
		% Parses each sublist separately
		parse_expression_aux(LeftExpression, LeftSyntaxTree),
		parse_expression_aux(RightExpression, RightSyntaxTree),
		% Builds the syntax tree
		SyntaxTree =.. [Operator, LeftSyntaxTree, RightSyntaxTree]
	;
		% Parses each sublist separately
		% (for prefix operators there's just 1 sublist)
		LeftExpression = [],
		parse_expression_aux(RightExpression, SingleSyntaxTree),
		% Builds the syntax tree
		(((Operator == '-' ; Operator == '+'), number(SingleSyntaxTree)) ->
			% This special treatment is needed in order to keep positive
			% and negative numbers as atomic (non-compound) terms, which is
			% the standard behavior according to ISO Prolog
			(Operator == '-' ->
				SyntaxTree is -SingleSyntaxTree
			;
				SyntaxTree is SingleSyntaxTree
			)
		;
			SyntaxTree =.. [Operator, SingleSyntaxTree]
		)
	).


%% highest_operator(+Expression, ?OpInfo)
%
%     Scans a "plain" expression list returned by term/3 DCG rule and
%     extracts the main operator, i.e., the highest priority operator
%     that should be placed as the root node of the syntax tree.
%     OpInfo will be unified with a list containing operator symbol,
%     precedence, type and index (related to Expression list).
%
%     @throws parse_error(Message, LineColumn) An operator
%      priority clash was detected.
%

%% highest_operator_aux(+Expression, +Index, +OpInfo, -FinalOpInfo)
%
%     Internal predicate used by highest_operator/2. Index specifies
%     the position of the first element in Expression list; FinalOpInfo
%     is unified with OpInfo when Expression list has no more items.
%
%     @throws parse_error(Message, LineColumn) An operator
%      priority clash was detected.
%
%     @see highest_operator/2
%

highest_operator(Expression, OpInfo) :-
	highest_operator_aux(Expression, 0, [_, -1, _, _], OpInfo).

highest_operator_aux([], _, OpInfo, OpInfo).

highest_operator_aux([Head|Tail], Index, OpInfo, FinalOpInfo) :-
	Head \= exp_operator(_, _, _),
	!,
	% If head item isn't an operator, go on analyzing the expression list
	NewIndex is Index + 1,
	highest_operator_aux(Tail, NewIndex, OpInfo, FinalOpInfo).

highest_operator_aux([Head|Tail], Index, [HighOp, HighPrio, HighType, HighPos], FinalOpInfo) :-
	nonvar(Head),
	Head = exp_operator(Op, Location, [LineOp, ColumnOp]),
	NewIndex is Index + 1,
	% Gets the type and precedence of the operator
	operator_type(Prio, Type, Op),
	(Location == infix ->
		member(Type, [xfx, xfy, yfx])
	;
		member(Type, [fx, fy])
	),
	% Checks if the operator is a '+' or '-' and the next term is a number
	(((Op == '-' ; Op == '+'), Type == fy,
	  Tail = [Number|_], number(Number)) ->
		% This special treatment is needed in order to ignore the '+' and
		% '-' operators that indicates the sign of a number, because
		% positive and negative numbers must be atomic (non-compound) terms
		% according to the ISO Prolog standard
		highest_operator_aux(Tail, NewIndex, [HighOp, HighPrio, HighType, HighPos],
		                     FinalOpInfo)
	;
		(Prio > HighPrio ->
			% A new highest operator was found
			highest_operator_aux(Tail, NewIndex, [Op, Prio, Type, Index], FinalOpInfo)
		;
		(Prio =:= HighPrio ->
			% If an expression has several operators with the same priority,
			% priority clash will happen if the type of one of the operators
			% ends with "x" and the next one starts with "x" or "f"
			% Examples: - xfy xfy fx yfx yfx -> OK
			%           - yfx yfx xfy xfy fx -> Priority clash (yfx xfy)
			%           - xfx yfx fy xfx fx -> Priority clash (yfx fy)
			(Type == yfx ->
				% Left associative, change highest operator
				highest_operator_aux(Tail, NewIndex, [Op, Prio, Type, Index], FinalOpInfo)
			;
			(((Type == xfy ; Type == xfx ; Type == fx ; Type == fy),
			  (HighType == xfy ; HighType == fy)) ->
				% Right associative, don't change highest operator
				highest_operator_aux(Tail, NewIndex, [HighOp, HighPrio, HighType, HighPos],
				                     FinalOpInfo)
			;
				% Operators can't be associated
				swritef(ErrorMessage, 'Operator priority clash caused by \'%w\'.', [Op]),
				throw(parse_error(ErrorMessage, [LineOp, ColumnOp]))
			))
		;
			% Keeps the current highest operator
			highest_operator_aux(Tail, NewIndex, [HighOp, HighPrio, HighType, HighPos],
			                     FinalOpInfo)
		))
	).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Predicates related with errors and warnings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% add_message(+Message, +Line, +Column, +Type)
%
%     Adds a new message to the list stored in messages/1. Error
%     messages should pass Type = 'error', whereas warning messages
%     should pass Type = 'warning'.
%

%% add_message(+Message, +Line, +Type)
%
%     Adds a new message to the list stored in messages/1. Error
%     messages should pass Type = 'error', whereas warning messages
%     should pass Type = 'warning'.
%

add_message(Message, Line, Column, Type) :-
	% Creates the text of the message
	bpl_filename(InputFile),
	upcase_atom(Type, UpperType),
	(InputFile == '' ->
		% InputFile should only be '' if a query is being parsed
		swritef(StringMessage, '%w: %w',
		        [UpperType, Message])
	;
		swritef(StringMessage, '%w: %w:%w:%w: %w',
		        [UpperType, InputFile, Line, Column, Message])
	),
	string_to_atom(StringMessage, TextMessage),
	% Updates the message list
	NewMessage = [InputFile, Line, Column, TextMessage, Type],
	add_message(NewMessage).

add_message(Message, Line, Type) :-
	% Creates the text of the message
	bpl_filename(InputFile),
	upcase_atom(Type, UpperType),
	(InputFile == '' ->
		% InputFile should only be '' if a query is being parsed
		swritef(StringMessage, '%w: %w',
		        [UpperType, Message])
	;
		swritef(StringMessage, '%w: %w:%w: %w',
		        [UpperType, InputFile, Line, Message])
	),
	string_to_atom(StringMessage, TextMessage),
	% Updates the message list
	NewMessage = [InputFile, Line, 0, TextMessage, Type],
	add_message(NewMessage).


%% add_message_in_file(+File, +Message, +Type)
%
%     Adds a new message to the list stored in messages/1, using
%     a different filename than the one kept in bpl_filename/1. Error
%     messages should pass Type = 'error', whereas warning messages
%     should pass Type = 'warning'.
%

add_message_in_file(File, Message, Type) :-
	% Creates the text of the message
	upcase_atom(Type, UpperType),
	swritef(StringMessage, '%w: %w: %w', [UpperType, File, Message]),
	string_to_atom(StringMessage, TextMessage),
	% Updates the message list
	NewMessage = [File, 0, 0, TextMessage, Type],
	add_message(NewMessage).


%% add_message(+Message)
%
%     Adds a new message to the list of messages stored in messages/1
%     dynamic predicate.
%

add_message(Message) :-
	messages(CurrentMessages),
	retract(messages(CurrentMessages)),
	assert(messages([Message|CurrentMessages])).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Predicates for processing goals and rules
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% add_degree_variables(+Term, -Result, -DegreeVars)
%
%     Scans Term, adds a degree variable to all the calls to
%     non-predefined predicates and returns the resulting term in
%     Result. DegreeVars will be unified with a list containing the
%     degree variables appended by this predicate. See
%     degree_variable_scanner/4 for an example.
%
%     @see degree_variable_scanner/4
%

add_degree_variables(Term, Result, DegreeVars) :-
	utilities:process_term(Term, Result,
	                       [parser:degree_variable_scanner],
	                       [parser:control_predicate_tester],
	                       [], DegreeVars).


%% add_block_constraints_variables(+Term, -Result, -BlockConstraintsVars)
%
%     If the selected weak unification algorithm is either 'a2' or 'a3', 
%     then scans Term, adds an input and output block constraints variables
%     to all the calls to non-predefined predicates and returns the 
%     resulting term in Result. BlockConstraintsVars will be unified
%     with a list containing the block constraints variables appended 
%     by this predicate. See
%     block_constraints_variables_scanner/4 for an example.
%     For other weak unification algorithms, Result is the same Term 
%     and BlockConstraintsVars is left as is.
%
%     @see block_constraints_variables_scanner/4
%

add_block_constraints_variables(Term, Term, _BlockConstraintsVars) :-
	flags:get_bpl_flag(weak_unification('a1')),
	!.

add_block_constraints_variables(Term, Result, BlockConstraintsVars) :-
	utilities:process_term(Term, Result,
	                       [parser:block_constraints_variables_scanner],
	                       [parser:control_predicate_tester],
	                       [], BlockConstraintsVars).


%% check_singleton(+Term, +Line)
%
%     Scans Term and looks for singleton variables (i.e., variables
%     which are used only once) and singleton-marked variables (i.e.,
%     variables which start with an underscore character). If at least
%     one singleton variable is found, a warning will be generated
%     using the specified Line. Besides, if at least one singleton-marked
%     variable is used more than once, another warning will be generated.
%     Note that, in this context, "variable" means "atom starting with
%     an uppercase letter or an underscore character".
%

check_singleton(Term, Line) :-
	% Extracts and counts all the variables of Term
	utilities:process_term(Term, _Result,
	                       [parser:get_variables_scanner],
	                       [],
	                       [], AllVars),
	% Gets the name of the variables that have been found only once,
	% ignoring the singleton-marked variables (those starting with '_')
	findall(Var, (member([Var, Count], AllVars),
	              atom_chars(Var, [First|_]), First \== '_',
	              (Count =:= 1)), SingletonVars),
	(SingletonVars \== [] ->
		% One or more singleton variables were found
		swritef(MessageSV, 'Singleton variables: %w', [SingletonVars]),
		add_message(MessageSV, Line, warning)
	;
		% No singleton variables were found
		true
	),
	% Gets the name of the singleton-marked variables (those starting with
	% '_' that aren't '_' itself) that have been found more than once
	findall(Var, (member([Var, Count], AllVars), Var \== '_',
	              atom_chars(Var, [First|_]), First == '_',
	              (Count > 1)), SingletonMarkedVars),
	(SingletonMarkedVars \== [] ->
		% One or more singleton-marked variables were found several times
		swritef(MessageSMV, 'Singleton-marked variables appearing more than \c
		                     once: %w', [SingletonMarkedVars]),
		add_message(MessageSMV, Line, warning)
	;
		% No repeated singleton-marked variables were found
		true
	).


%% check_free_variables(+Term, +Line, +IsGoal)
%
%     Scans Term and looks for variables that are being used as
%     subclauses. If at least one variable is found, this predicate
%     will generate a warning using specified Line. IsGoal specifies
%     whether Term represents a goal (true) or a clause (false). Note
%     that, in this context, "variable" means "atom starting with an
%     uppercase letter or an underscore character".
%

check_free_variables(Term, _Line, false) :-
	var(Term),
	!.

check_free_variables(Term, _Line, true) :-
	(var(Term) ; atomic(Term)),
	!.

check_free_variables(_Head :- Body, Line, IsGoal) :-
	% If Term is a clause, only its body is scanned
	!,
	check_free_variables(Body, Line, IsGoal).

check_free_variables(Term, Line, IsGoal) :-
	!,
	% Extracts and counts all the variables of Term
	% (non-control compound terms are skipped)
	utilities:process_term(Term, _Result,
	                       [parser:get_variables_scanner],
	                       [parser:control_predicate_tester],
	                       [], AllVars),
	% If at least one variable is found, a warning is generated
	(AllVars \== [] ->
		findall(Var, member([Var, _Count], AllVars), VarNames),
		(IsGoal == true ->
			swritef(Message, 'Goals are not allowed to have free variables \c
			                  as subgoals: %w. Program may throw an \c
			                  exception at runtime. Please use call/1 \c
			                  instead.', [VarNames])
		;
			swritef(Message, 'Clauses are not allowed to have free variables \c
			                  as subclauses: %w. Program may throw an \c
			                  exception at runtime. Please use call/1 \c
			                  instead.', [VarNames])
		),
		add_message(Message, Line, warning)
	;
		true
	).


%% degree_variable_scanner(+Term, -Result, +InData, -OutData)
%
%     Scanner that can be used with process_term/6 to add a degree
%     variable to each call to a user-defined predicate and get the
%     new degree variables in OutData. For every Term that is a
%     compound term with a non-predefined functor, Result will be
%     unified with a new term with the following components:
%
%      * Functor: concatenation of the prefix stored in
%        program_prefix/1, an underscore character '_' and the original
%        functor.
%      * Arguments: the ones in the original term plus a new free
%        variable which will store the approximation degree.
%
%     For example, given Term = 'pred(X, 1)', this predicate will
%     return Result = 'prog_pred(X, 1, DegreeVar)' (if program_prefix/1
%     contains 'prog') and OutData = [DegreeVar|InData].
%
%     If Term is a call to a predefined predicate (for example,
%     'append([1], X, [1, 2])'), Result and OutData will be unified
%     with Term and InData, respectively.
%
%     @see process_term/6
%

degree_variable_scanner(Term, NewTerm, DegreeVars, NewDegreeVars) :-
	nonvar(Term),
	not(number(Term)),
	!,
	Term =.. [Functor|Args],
	(utilities:atom_is_variable(Functor) ->
		% Term represents a variable, so it can be ignored
		NewTerm = Term,
		NewDegreeVars = DegreeVars
	;
		(Functor == 'eval_negation' ->
			% Gets the degree variable of the negation, which must be
			% the last argument of the eval_negation term
			NewTerm = Term,
			append(_, [NewDegreeVar], Args),
			% Updates the dynamic degree variable list
			NewDegreeVars = [NewDegreeVar|DegreeVars]
		;
		((utilities:builtin(Term) ; utilities:is_quoted(Functor, '\'') ;
		  Functor == '^') ->
			% Term is a call to a predefined predicate or a quoted term,
			% so it can be ignored
			NewTerm = Term,
			NewDegreeVars = DegreeVars
		;
			% Adds the degree variable to the scanned term
			%var(NewDegreeVar),
			append(Args, [NewDegreeVar], NewArgs),
			program_prefix(ProgramName),
			concat_atom([ProgramName, '_', Functor], NewFunctor),
			NewTerm =.. [NewFunctor|NewArgs],
			% Updates the dynamic degree variable list
			NewDegreeVars = [NewDegreeVar|DegreeVars]
		))
	).

degree_variable_scanner(Term, Term, DegreeVars, DegreeVars).
	% Term can be ignored because it's a variable or a number


%% block_constraints_variables_scanner(+Term, -Result, +InData, -OutData)
%
%     Scanner that can be used with process_term/6 to add an input
%     and output block constraint variables to each call to a 
%     user-defined predicate, and get both the new block constraint
%     variables in OutData. For every Term that is a compound term
%     with a non-predefined functor, Result will be unified with a 
%     new term with the same functor as Term and:
%
%      * Arguments: the ones in the original term plus two new free
%        variables which will store the input and output block
%        constraints stores. They are placed just before the degree.
%
%     For example, given:
%         Term   = 'prog_pred(X, 1, DegreeVar)', this 
%     predicate will return 
%         Result  = 'prog_pred(X, 1, Cin, Cout, DegreeVar)', and
%         OutData = InData ++ [Cin, Cout].
%
%     If Term is a call to a predefined predicate (for example,
%     'append([1], X, [1, 2])'), Result and OutData will be unified
%     with Term and InData, respectively.
%
%     @see process_term/6
%

block_constraints_variables_scanner(Term, NewTerm, InData, OutData) :-
	nonvar(Term),
	not(number(Term)),
	!,
	Term =.. [Functor|Args],
	(utilities:atom_is_variable(Functor) ->
		% Term represents a variable, so it can be ignored
		NewTerm = Term,
		OutData = InData
	;
		(Functor == 'eval_negation' ->
			% Gets the block constraints variables list of the negation, 
			% which must be the last but two argument of the eval_negation term :: WARNING: TODO
			NewTerm = Term,
			append(_, [Ctrs, _, _DegreeVar], Args),
			% Updates the dynamic degree variable list
			append(InData, Ctrs, OutData)
		;
		((utilities:builtin(Term) ; utilities:is_quoted(Functor, '\'') ;
		  Functor == '^') ->
			% Term is a call to a predefined predicate or a quoted term,
			% so it can be ignored
			NewTerm = Term,
  		OutData = InData
		;
			% Adds the block constraints variables to the scanned term
			% var(Cin),
			% var(Cout),
			Ctrs = [Cin, _Cout],
			append(ArgsWithoutDegreeVar, [NewDegreeVar], Args),
			append(ArgsWithoutDegreeVar, Ctrs, NewArgsWithoutDegreeVar),
			append(NewArgsWithoutDegreeVar, [NewDegreeVar], NewArgs),
			NewTerm =.. [Functor|NewArgs],
			% Updates the block constraints variables list
			append(InData, Ctrs, OutData),
			% Links the last block constraints store in InData with Cin
			(InData == [] ->
			  true % Nothing to link with
			 ;
			  append(_,[Cin],InData)
			)
		))
	).

block_constraints_variables_scanner(Term, Term, InData, InData).
	% Term can be ignored because it's a variable or a number


%% get_variables_scanner(+Term, -Result, +InData, -OutData)
%
%     Scanner that can be used with process_term/6 to count the
%     occurrences of each variable in a term and save them in OutData as
%     a list containing [Term, Count] parings. This scanner always
%     unifies Result with Term. Note that, in this context, "variable"
%     means "atom starting with an uppercase letter or an underscore
%     character".
%
%     @see process_term/6
%

get_variables_scanner(Term, Term, CurrentVars, NewVars) :-
	atom(Term),
	% Term is an atom; if its first char is uppercase, then it represents
	% a variable (variables starting with an underscore character are ignored)
	!,
	(utilities:atom_is_variable(Term) ->
		% Term represents a variable, so it must be added to
		% the list of current variables
		(member([Term, Count], CurrentVars) ->
			% This variable has already been found before
			delete(CurrentVars, [Term, Count], CurrentVarsWithoutTerm),
			NewCount is Count + 1,
			NewVars = [[Term, NewCount]|CurrentVarsWithoutTerm]
		;
			% This is the first ocurrence of this variable
			NewVars = [[Term, 1]|CurrentVars]
		)
	;
		% Term doesn't represent a variable
		NewVars = CurrentVars
	).

get_variables_scanner(Term, Term, Vars, Vars).
	% Term can be ignored because it isn't an atom


%% control_predicate_tester(+Term)
%
%     Tester that can be used with process_term/6 to scan a clause or
%     goal. This tester fails only when Term is a compound term with a
%     functor different from ,/2, ;/2, ->/2 and *->/2.
%
%     @see process_term/6
%

control_predicate_tester(Term) :-
	compound(Term),
	!,
	functor(Term, Functor, _Arity),
	(Functor == ',' ; Functor == ';' ; Functor == '->' ; Functor == '*->').

control_predicate_tester(_Term).
	% Tester always succeed for non-compound terms



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Miscellaneous predicates
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% declare_custom_operator(+Precedence, +Type, +Names)
%
%     Adds each of the operators in Names list to the custom operator
%     list, using specified type and precedence.
%

declare_custom_operator(_, _, []).

declare_custom_operator(Precedence, Type, [Name|MoreOps]) :-
	custom_operators(CurrentOpList),
	retract(custom_operators(CurrentOpList)),
	assert(custom_operators([[Precedence, Type, Name]|CurrentOpList])),
	declare_custom_operator(Precedence, Type, MoreOps).


%% operator_type(?Precedence, ?Type, +Name)
%
%     Succeeds if Name is currently defined as a predefined or custom
%     operator with specified type and precedence.
%

operator_type(Precedence, Type, Name) :-
	% Checks if the operator is a predefined one
	current_op(Precedence, Type, Name),
	Name\=='.'. % SWI-Prolog 7.x add the dot as an infix operator for dicts.

operator_type(Precedence, Type, Name) :-
	% Checks if the operator is a custom operator declared
	% by the user with the op/3 directive
	custom_operators(CustomOpList),
	member([Precedence, Type, Name], CustomOpList).


%% add_call_after_bindings(+Term, -ResultTerm)
%
%     Encloses the first (most shallow) term in Term which doesn't use
%     the existential operator ^/2 with a bpl_call/1 term.
%
%     For example, given Term = (X ^ write(X)), this predicate will
%     return ResultTerm = (X ^ bpl_call(write(X)).
%

add_call_after_bindings(Var ^ Term, Var ^ ResultTerm) :-
	add_call_after_bindings(Term, ResultTerm).

add_call_after_bindings(Term, bpl_call(Term)).


%% bind_term(+Variables, +Term, -BoundTerm)
%
%     Binds Term with all the variables in the Variables list using
%     the existencial quantification operator (^) and returns the
%     result in BoundTerm. For example, given Variables = [A, B] and
%     Term = 'pred(A, B, C)', this predicate will return BoundTerm =
%     'A ^ B ^ pred(A, B, C)'.
%

bind_term([], Term, Term).

bind_term([Var|MoreVars], Term, BoundTerm) :-
	BoundTerm = Var ^ ContTerm,
	bind_term(MoreVars, Term, ContTerm).


%% reset_parser
%
%     Resets custom operators, messages and linguistic terms.
%

reset_parser :-
	custom_operators(OldOperators),
	retract(custom_operators(OldOperators)),
	assert(custom_operators([])),
	messages(OldMessages),
	retract(messages(OldMessages)),
	assert(messages([])),
	linguistic_terms(OldLingTerms),
	retract(linguistic_terms(OldLingTerms)),
	assert(linguistic_terms([])).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Constant predicates
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% higher_order_predicate(?Name, ?Arguments)
%
%     Succeeds if Name is the name of a higher-order predicate
%     supported by Bousi-Prolog, and Arguments is a list containing
%     the description of its arguments. Each item of Arguments can be
%     either 'goal', 'nongoal' or 'atom' (just for assert/1 and
%     retract/1).
%

higher_order_predicate(assert,  [atom]).
higher_order_predicate(retract, [atom]).
higher_order_predicate(call,    [goal]).
higher_order_predicate(once,    [goal]).
higher_order_predicate(ignore,  [goal]).
higher_order_predicate(time,    [goal]).
higher_order_predicate(apply,   [nongoal, nongoal]).
higher_order_predicate(maplist, [nongoal, nongoal]).
higher_order_predicate(forall,  [goal, goal]).
higher_order_predicate(findall, [nongoal, goal, nongoal]).
higher_order_predicate(bagof,   [nongoal, goal, nongoal]).
higher_order_predicate(setof,   [nongoal, goal, nongoal]).
higher_order_predicate(catch,   [goal, nongoal, goal]).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dynamic predicates
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% program_prefix(?Name)                                     is dynamic
%
%     Dynamic predicate which stores the prefix corresponding to the
%     main BPL source code file (if a program is being parsed), or to
%     the currently loaded Bousi-Prolog program (if a query is being
%     parsed).
%

:- dynamic program_prefix/1.

program_prefix('none').


%% bpl_filename(?Filename)                                   is dynamic
%
%     Dynamic predicate which stores the name of the BPL source code
%     file that's being parsed.
%

:- dynamic bpl_filename/1.

bpl_filename('').


%% messages(?Messages)                                       is dynamic
%
%     Dynamic predicate which stores all warnings and errors generated
%     during lexical, syntactic and semantic analysis. Each warning and
%     error must be a list with five items: file name, line number,
%     column number, message text, and message type ('warning' or
%     'error').
%

:- dynamic messages/1.

messages([]).


%% custom_operators(?OpList)                                 is dynamic
%
%     Dynamic predicate which stores custom operators declared in
%     source code files using the op/3 Prolog directive. Each operator
%     is defined by a list with three items: precedence, type, and
%     name.
%

:- dynamic custom_operators/1.

custom_operators([]).


%% linguistic_terms(?LingTerms)                              is dynamic
%
%     Dynamic predicate which stores all linguistic terms built with
%     the '#' operator found in source code (such as 'age#30' or
%     'very#tall'). Each linguistic term is defined using a list with
%     three items: the first two can be 'domain' followed by the name
%     of an existing domain or 'subset' followed by the name of a
%     fuzzy subset, while the last one must be the definition of the
%     subset, as required by ext_translate_fuzzysets/5.
%

:- dynamic linguistic_terms/1.

linguistic_terms([]).

